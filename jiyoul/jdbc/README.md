트랜잭션 ACID
* 원자성
- 트랙잭션 내에서 실행한 작업들은 하나의 작업처럼 모두 성공이거나 모두 실패해야 한다.
* 일관성
- 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.
- 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 함.
* 격리성
- 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않아야 한다.
- 동시에 같은 데이터를 수정하지 못해야 함.
- 격리성은 동시성과 관련된 선 이슈로 트랙잭션 격리 수준을 선택할 수 있다. (Isolation level)

* 지속성
- 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.
- 중간에 시스템에 문제가 발생하더라도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 함.

트랜잭션 격리수준 (Isolation Level)
READ UNCOMMITTED (커밋되지 않은 데이터도 읽기)
READ COMMITTED (커밋된 데이터 읽기)
REPEATABLE READ (반복 가능한 읽기)
SERIALIZABLE (직렬화 가능)

트랜잭션 격리 수준은 아래로 갈수록 성능이 감소함.
일반적으로는 READ COMMITTED를 사용함.

데이터를 수정하는 로직에서는 LOCK 이 걸리고 해당 컬럼을 다른 트랜잭션에서 변경하려고 할때에는
LOCK이 풀릴때까지 대기한다.

SELECT 에서는 LOCK 이 걸리지도 않고 LOCK 과 상관없이 조회가 가능하지만 for update 로 SELECT 를 하게 되는 경우에는 LOCK 을 걸 수 있다.

LOCK은 커밋과 동시에 자동으로 풀리게 된다.
LOCK은 조금이라도 먼저온 세션(DB 서버 내부의 세션으로 클라와 커넥션 맺는것) 에게 우선적으로 부여된다.

==================================================================================================================================

트랜잭션 동작 방식
1. 서비스에서 트랜잭션을 시작하려면 커넥션이 필요하다
2. 트랜잭션 매니저가 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작한다. (setAutoCommit(false) 등 이떄 데이터소스를 보고 설정 함.)
3. 트랜잭션 매니저는 시작된 트랜잭션의 커넥션을 트랜잭션 동기화 매니저에 보관한다.
4. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. (멀티 쓰레드 환경에서도 안전하게 보관할 수 있음.)
5. 레포지토리는 트랜잭션이 시작된 커넥션이 필요하므로 트랜잭션 동기화 매니저에 보관된 커넥션을(이미 시작된 커넥션임) 꺼내서 사용한다. 
   (따라서 서비스는 레포지토리에 로직을 사용할 때 자신의 커넥션을 파라미터로 전달하지 않아도 같은 커넥션을 유지함.)
6. 서비스에서 커밋이랑 롤백을 할 경우 트랜잭션 매니저는 트랜잭션 동기화 매니저에 있는 커넥션을 꺼내서 종료하고 커넥션도 닫고 지움. 

==================================================================================================================================

@Transactional 사용시

SpringBoot 가 트랜잭션 AOP 를 적용하기 위해 어드바이저, 포인트 컷, 어드바이스를
스프링 컨테이너에 자동으로 등록해 준다.
어드바이저 : BeanFactoryTransactionAttributeSourceAdvisor
포인트컷 : TransactionAttributeSourcePointCut
어드바이스 : TransactionInterceptor

==================================================================================================================================

AOP @Transactional 사용시 동작 방식
1. 클라이언트(컨트롤러 등) 에서 AOP 프록시를 호출한다.
2. AOP 프록시는 스프링 컨테이너를 통해 트랜잭션 매니저를 획득한다.
3. 트랜잭션매니저의 getTransaction 을 시작한다.
4. 트랜잭션매니저에서는 데이터소스를 가지고 커넥션을 만든다.(데이터소스는 application.properties 에 설정해서 많이 사용.)
5. setAutoCommit(false) 를 사용해서 수동 커밋 모드로 만들며 트랜잭션을 시작한다. 
6. 해당 트랜잭션은 트랜잭션 동기화 매니저에 보관시킨다.
7. AOP 프록시는 실제 서비스 로직을 호출한다.
8. 서비스 로직에서는 레포지토리를 호출한다.
9. 레포지토리에서는 트랜잭션 동기화 커넥션을 통해 커넥션을 획득하고 처리한다.
10. 서비스로 결과값을 리턴해준다. 서비스도 AOP 프록시에 리턴한다.
11. AOP 프록시에서 결과가 정상이면 commit, 실패면 rollback 로직을 수행하고 트랜잭션을 종료하고 커넥션을 닫는데
      커넥션 풀을 사용 한다면 풀에 반환된다.
12. AOP 프록시 트랜잭션 처리 결과 값을 클라이언트에 반환한다.
 