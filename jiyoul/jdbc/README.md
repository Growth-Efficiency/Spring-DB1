트랜잭션 ACID
* 원자성
- 트랙잭션 내에서 실행한 작업들은 하나의 작업처럼 모두 성공이거나 모두 실패해야 한다.
* 일관성
- 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.
- 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 함.
* 격리성
- 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않아야 한다.
- 동시에 같은 데이터를 수정하지 못해야 함.
- 격리성은 동시성과 관련된 선 이슈로 트랙잭션 격리 수준을 선택할 수 있다. (Isolation level)

* 지속성
- 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다.
- 중간에 시스템에 문제가 발생하더라도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 함.

트랜잭션 격리수준 (Isolation Level)
READ UNCOMMITTED (커밋되지 않은 데이터도 읽기)
READ COMMITTED (커밋된 데이터 읽기)
REPEATABLE READ (반복 가능한 읽기)
SERIALIZABLE (직렬화 가능)

트랜잭션 격리 수준은 아래로 갈수록 성능이 감소함.
일반적으로는 READ COMMITTED를 사용함.

데이터를 수정하는 로직에서는 LOCK 이 걸리고 해당 컬럼을 다른 트랜잭션에서 변경하려고 할때에는
LOCK이 풀릴때까지 대기한다.

SELECT 에서는 LOCK 이 걸리지도 않고 LOCK 과 상관없이 조회가 가능하지만 for update 로 SELECT 를 하게 되는 경우에는 LOCK 을 걸 수 있다.

LOCK은 커밋과 동시에 자동으로 풀리게 된다.
LOCK은 조금이라도 먼저온 세션(DB 서버 내부의 세션으로 클라와 커넥션 맺는것) 에게 우선적으로 부여된다.

==================================================================================================================================

트랜잭션 동작 방식
1. 서비스에서 트랜잭션을 시작하려면 커넥션이 필요하다
2. 트랜잭션 매니저가 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작한다. (setAutoCommit(false) 등 이떄 데이터소스를 보고 설정 함.)
3. 트랜잭션 매니저는 시작된 트랜잭션의 커넥션을 트랜잭션 동기화 매니저에 보관한다.
4. 트랜잭션 동기화 매니저는 쓰레드 로컬에 커넥션을 보관한다. (멀티 쓰레드 환경에서도 안전하게 보관할 수 있음.)
5. 레포지토리는 트랜잭션이 시작된 커넥션이 필요하므로 트랜잭션 동기화 매니저에 보관된 커넥션을(이미 시작된 커넥션임) 꺼내서 사용한다. 
   (따라서 서비스는 레포지토리에 로직을 사용할 때 자신의 커넥션을 파라미터로 전달하지 않아도 같은 커넥션을 유지함.)
6. 서비스에서 커밋이랑 롤백을 할 경우 트랜잭션 매니저는 트랜잭션 동기화 매니저에 있는 커넥션을 꺼내서 종료하고 커넥션도 닫고 지움. 